#version 450

#include "lib/utils.glsl"


layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0) uniform sampler2D in_ao;
layout(set = 0, binding = 1) uniform sampler2D in_low_res_lindepth;
layout(set = 0, binding = 2) uniform sampler2D in_hi_res_depth;

layout(set = 0, binding =  3) uniform CameraData {
    Camera camera;
};

layout(r8, set = 0, binding = 4) uniform writeonly image2D out_ao;


const float StepSize = 2.0;
const float kUpsampleTolerance = pow(10, -12.0);

shared float DepthCache[256];
shared float AOCache1[256];
shared float AOCache2[256];

void PrefetchData(uint index, vec2 uv) {
    vec4 AO1 = textureGather(in_ao, uv);
    AOCache1[index]         = AO1.w;
    AOCache1[index + 1]     = AO1.z;
    AOCache1[index + 16]    = AO1.x;
    AOCache1[index + 17]    = AO1.y;

    vec4 ID = 1.0 / textureGather(in_low_res_lindepth, uv);
    DepthCache[index]       = ID.w;
    DepthCache[index + 1]   = ID.z;
    DepthCache[index + 16]  = ID.x;
    DepthCache[index + 17]  = ID.y;
}

float SmartBlur(float a, float b, float c, float d, float e, bool left, bool middle, bool right) {
    b = left || middle ? b : c;
    a = left ? a : b;
    d = right || middle ? d : c;
    e = right ? e : d;
    return ((a + e) / 2.0 + b + c + d) / 4.0;
}

bool CompareDeltas(float d1, float d2, float l1, float l2) {
    const float kBlurTolerance = sqr(1 - pow(10, -4.6) * StepSize);
    float temp = d1 * d2 + StepSize;
    return temp * temp > l1 * l2 * kBlurTolerance;
}

void BlurHorizontally(uint left_index) {
    float a0 = AOCache1[left_index];
    float a1 = AOCache1[left_index + 1];
    float a2 = AOCache1[left_index + 2];
    float a3 = AOCache1[left_index + 3];
    float a4 = AOCache1[left_index + 4];
    float a5 = AOCache1[left_index + 5];
    float a6 = AOCache1[left_index + 6];

    float d0 = DepthCache[left_index];
    float d1 = DepthCache[left_index + 1];
    float d2 = DepthCache[left_index + 2];
    float d3 = DepthCache[left_index + 3];
    float d4 = DepthCache[left_index + 4];
    float d5 = DepthCache[left_index + 5];
    float d6 = DepthCache[left_index + 6];

    float d01 = d1 - d0;
    float d12 = d2 - d1;
    float d23 = d3 - d2;
    float d34 = d4 - d3;
    float d45 = d5 - d4;
    float d56 = d6 - d5;

    float l01 = d01 * d01 + StepSize;
    float l12 = d12 * d12 + StepSize;
    float l23 = d23 * d23 + StepSize;
    float l34 = d34 * d34 + StepSize;
    float l45 = d45 * d45 + StepSize;
    float l56 = d56 * d56 + StepSize;

    bool c02 = CompareDeltas(d01, d12, l01, l12);
    bool c13 = CompareDeltas(d12, d23, l12, l23);
    bool c24 = CompareDeltas(d23, d34, l23, l34);
    bool c35 = CompareDeltas(d34, d45, l34, l45);
    bool c46 = CompareDeltas(d45, d56, l45, l56);

    AOCache2[left_index + 0] = SmartBlur(a0, a1, a2, a3, a4, c02, c13, c24);
    AOCache2[left_index + 1] = SmartBlur(a1, a2, a3, a4, a5, c13, c24, c35);
    AOCache2[left_index + 2] = SmartBlur(a2, a3, a4, a5, a6, c24, c35, c46);
}

void BlurVertically(uint top_index) {
    float a0 = AOCache2[top_index];
    float a1 = AOCache2[top_index + 16];
    float a2 = AOCache2[top_index + 32];
    float a3 = AOCache2[top_index + 48];
    float a4 = AOCache2[top_index + 64];
    float a5 = AOCache2[top_index + 80];

    float d0 = DepthCache[top_index + 2];
    float d1 = DepthCache[top_index + 18];
    float d2 = DepthCache[top_index + 34];
    float d3 = DepthCache[top_index + 50];
    float d4 = DepthCache[top_index + 66];
    float d5 = DepthCache[top_index + 82];

    float d01 = d1 - d0;
    float d12 = d2 - d1;
    float d23 = d3 - d2;
    float d34 = d4 - d3;
    float d45 = d5 - d4;

    float l01 = d01 * d01 + StepSize;
    float l12 = d12 * d12 + StepSize;
    float l23 = d23 * d23 + StepSize;
    float l34 = d34 * d34 + StepSize;
    float l45 = d45 * d45 + StepSize;

    bool c02 = CompareDeltas(d01, d12, l01, l12);
    bool c13 = CompareDeltas(d12, d23, l12, l23);
    bool c24 = CompareDeltas(d23, d34, l23, l34);
    bool c35 = CompareDeltas(d34, d45, l34, l45);

    float aoResult1 = SmartBlur(a0, a1, a2, a3, a4, c02, c13, c24);
    float aoResult2 = SmartBlur(a1, a2, a3, a4, a5, c13, c24, c35);

    AOCache1[top_index]         = aoResult1;
    AOCache1[top_index + 16]    = aoResult2;
}

// We essentially want 5 weights:  4 for each low-res pixel and 1 to blend in when none of the 4 really
// match.  The filter strength is 1 / DeltaZTolerance.  So a tolerance of 0.01 would yield a strength of 100.
// Note that a perfect match of low to high depths would yield a weight of 10^6, completely superceding any
// noise filtering.  The noise filter is intended to soften the effects of shimmering when the high-res depth
// buffer has a lot of small holes in it causing the low-res depth buffer to inaccurately represent it.
float BilateralUpsample(float HiDepth, float HiAO, vec4 LowDepths, vec4 LowAO) {
    const float NoiseFilterStrength = 1.0 / (pow(10.0, 0.0) + kUpsampleTolerance);
    vec4 weights = vec4(9.0, 3.0, 1.0, 3.0) / ( abs(HiDepth - LowDepths) + kUpsampleTolerance);
    float TotalWeight = dot(weights, vec4(1.0)) + NoiseFilterStrength;
    float WeightedSum = dot(LowAO, weights) + NoiseFilterStrength;
    return HiAO * WeightedSum / TotalWeight;
}



#define LINEARIZE(depth) linearize(depth, camera.z_near, camera.z_far)

void main() {
    const vec2 low_res = vec2(textureSize(in_low_res_lindepth, 0).xy);
    const vec2 hi_res = vec2(textureSize(in_hi_res_depth, 0).xy);
    const vec2 inv_low_res = 1.0 / low_res;
    const vec2 inv_hi_res = 1.0 / hi_res;

    PrefetchData(gl_LocalInvocationID.x << 1 | gl_LocalInvocationID.y << 5, ivec2(gl_GlobalInvocationID.xy + gl_LocalInvocationID.xy - 2) * inv_low_res);
    barrier();

    // Goal:  End up with a 9x9 patch that is blurred so we can upsample.  Blur radius is 2 pixels, so start with 13x13 area.

    //
    // Horizontally blur the pixels.    13x13 -> 9x13
    //
    if(gl_LocalInvocationIndex < 39) {
        BlurHorizontally((gl_LocalInvocationIndex / 3) * 16 + (gl_LocalInvocationIndex % 3) * 3);
    }
    barrier();

    //
    // Vertically blur the pixels.        9x13 -> 9x9
    //
    if(gl_LocalInvocationIndex < 45) {
        BlurVertically((gl_LocalInvocationIndex / 9) * 32 + gl_LocalInvocationIndex % 9);
    }
    barrier();

    //
    // Bilateral upsample
    //
    uint Idx0 = gl_LocalInvocationID.x + gl_LocalInvocationID.y * 16;
    vec4 LoSSAOs = vec4(AOCache1[Idx0 + 16], AOCache1[Idx0 + 17], AOCache1[Idx0 + 1], AOCache1[Idx0]);

    // We work on a quad of pixels at once because then we can gather 4 each of high and low-res depth values
    vec2 uv0 = gl_GlobalInvocationID.xy * inv_low_res;
    vec2 uv1 = gl_GlobalInvocationID.xy * inv_hi_res * 2;


    vec4 HiSSAOs = vec4(1.0);
    vec4 LoDepths = textureGather(in_low_res_lindepth, uv0);
    vec4 HiDepths = textureGather(in_hi_res_depth, uv1);
    HiDepths.x = LINEARIZE(HiDepths.x);
    HiDepths.y = LINEARIZE(HiDepths.y);
    HiDepths.z = LINEARIZE(HiDepths.z);
    HiDepths.w = LINEARIZE(HiDepths.w);

    ivec2 OutST = ivec2(gl_GlobalInvocationID.xy) << 1;
    imageStore(out_ao, OutST + ivec2(-1,  0), vec4(BilateralUpsample(HiDepths.x, HiSSAOs.x, LoDepths.xyzw, LoSSAOs.xyzw)));
    imageStore(out_ao, OutST + ivec2( 0,  0), vec4(BilateralUpsample(HiDepths.y, HiSSAOs.y, LoDepths.yzwx, LoSSAOs.yzwx)));
    imageStore(out_ao, OutST + ivec2( 0, -1), vec4(BilateralUpsample(HiDepths.z, HiSSAOs.z, LoDepths.zwxy, LoSSAOs.zwxy)));
    imageStore(out_ao, OutST + ivec2(-1, -1), vec4(BilateralUpsample(HiDepths.w, HiSSAOs.w, LoDepths.wxyz, LoSSAOs.wxyz)));
}

