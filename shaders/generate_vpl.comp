#version 450

#include "lib/gbuffer.glsl"
#include "lib/vpl.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0) uniform sampler2D in_depth;
layout(set = 0, binding = 1) uniform sampler2D in_rt0;
layout(set = 0, binding = 2) uniform sampler2D in_rt1;

layout(set = 0, binding = 3) uniform CameraData {
    Camera camera;
};

layout(set = 0, binding = 4) uniform Light {
    DirectionalLight light;
};

layout(set = 0, binding = 5) writeonly buffer VPLs {
    VPL vpls[];
};



void main() {
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const uvec2 size = gl_NumWorkGroups.xy * gl_WorkGroupSize.xy;
    const uint global_index = gl_GlobalInvocationID.y * size.y + gl_GlobalInvocationID.x;
    const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(size);

    const float depth = texelFetch(in_depth, coord, 0).x;
    const SurfaceInfo surface = read_gbuffer(texelFetch(in_rt0, coord, 0), texelFetch(in_rt1, coord, 0));

    const float NoL = max(0.0, -dot(surface.normal, light.direction));
    const vec3 world_pos = unproject(uv, depth, camera.inv_view_proj);

    VPL vpl;
    vpl.position = world_pos;
    vpl.color = surface.albedo * light.color * NoL;
    vpl.normal = surface.normal;

    vpls[global_index] = vpl;
}

