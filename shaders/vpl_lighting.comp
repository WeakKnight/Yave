#version 450

#include "lib/gbuffer.glsl"
#include "lib/vpl.glsl"
#include "lib/noise.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0) uniform sampler2D in_depth;
layout(set = 0, binding = 1) uniform sampler2D in_rt0;
layout(set = 0, binding = 2) uniform sampler2D in_rt1;

layout(set = 0, binding = 3) uniform CameraData {
    Camera camera;
};

layout(set = 0, binding = 4) readonly buffer VPLs {
    VPL vpls[];
};

layout(rgba16f, set = 0, binding = 5) uniform image2D out_color;

const uint vpl_count = 256 * 256;
const uint sample_count = 256;

void main() {
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(imageSize(out_color).xy);

    const float depth = texelFetch(in_depth, coord, 0).x;
    const SurfaceInfo surface = read_gbuffer(texelFetch(in_rt0, coord, 0), texelFetch(in_rt1, coord, 0));

    const vec3 world_pos = unproject(uv, depth, camera.inv_view_proj);

    vec3 irradiance = vec3(0.0);

    float offset = hash_1_2(uv);
    for(uint i = 0; i != sample_count; ++i) {
        offset = hash_1_1(offset + i);
        const VPL vpl = vpls[uint(offset * vpl_count)];

        vec3 light_dir = vpl.position - world_pos;
        const float distance = length(light_dir);
        light_dir /= distance;

        const float NoL = dot(light_dir, surface.normal);
        if(NoL > 0.0) {
            const float att = 1.0 / sqr(distance + 1.0);
            irradiance += vpl.color * (att * NoL);
        }
    }

    const float norm_factor = float(vpl_count) / float(sample_count);

    imageStore(out_color, coord, vec4(irradiance * norm_factor, 1.0));

}

